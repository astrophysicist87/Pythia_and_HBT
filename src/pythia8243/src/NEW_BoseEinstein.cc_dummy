// BoseEinstein.cc is a part of the PYTHIA event generator.
// Copyright (C) 2019 Torbjorn Sjostrand.
// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
// Please respect the MCnet Guidelines, see GUIDELINES for details.

// Function definitions (not found in the header) for the BoseEinsten class.

#include "Pythia8/BoseEinstein.h"

#include <ostream>
#include <chrono>

namespace Pythia8 {

//==========================================================================

// The BoseEinstein class.

//--------------------------------------------------------------------------

// Constants: could be changed here if desired, but normally should not.
// These are of technical nature, as described for each.

///===CJP(begin)===

const int npts = 15;
const double x_pts[15] = { -0.98799251802048543,
							  -0.93727339240070590,
							  -0.84820658341042722,
							  -0.72441773136017005,
							  -0.57097217260853885,
							  -0.39415134707756337,
							  -0.20119409399743452,
							  0.0,
							  0.20119409399743452,
							  0.39415134707756337,
							  0.57097217260853885,
							  0.7244177313601700,
							  0.8482065834104272,
							  0.9372733924007059,
							  0.9879925180204854};

const double x_wts[15] = { 0.03075324199611726835,
							  0.07036604748810812471,
							  0.10715922046717193501,
							  0.1395706779261543144,
							  0.1662692058169939336,
							  0.1861610000155622110,
							  0.1984314853271115765,
							  0.2025782419255612729,
							  0.1984314853271115765,
							  0.1861610000155622110, 
							  0.1662692058169939336,
							  0.1395706779261543144,
							  0.10715922046717193501,
							  0.07036604748810812471,
							  0.03075324199611726835};

// Enumeration of id codes and table for particle species considered.
const int    BoseEinstein::IDHADRON[9] = { 211, -211, 111, 321, -321,
                                           130,  310, 221, 331 };
const int    BoseEinstein::ITABLE[9] = { 0, 0, 0, 1, 1, 1, 1, 2, 3 };

// Distance between table entries, normalized to min( 2*mass, QRef).
const double BoseEinstein::STEPSIZE  = 0.05;
//const double BoseEinstein::STEPSIZE  = 0.01;

// Skip shift for two extremely close particles, to avoid instabilities.
const double BoseEinstein::Q2MIN     = 1e-8;

// Parameters of energy compensation procedure: maximally allowed
// relative energy error, iterative stepsize, and number of iterations.
const double BoseEinstein::COMPRELERR = 1e-10;
const double BoseEinstein::COMPFACMAX = 1000.;
const int    BoseEinstein::NCOMPSTEP  = 10;

const double BoseEinstein::dQ = 1e-4;
const double BoseEinstein::Qmaximum = 1.0;

const bool BoseEinstein::BE_VERBOSE = false;

//--------------------------------------------------------------------------

// Find settings. Precalculate table used to find momentum shifts.

bool BoseEinstein::init(Info* infoPtrIn, Settings& settings,
  ParticleData& particleData) {

  // Save pointer.
  infoPtr                = infoPtrIn;

  // Main flags.
  doPion 				          = settings.flag("BoseEinstein:Pion");
  doKaon 				          = settings.flag("BoseEinstein:Kaon");
  doEta 				          = settings.flag("BoseEinstein:Eta");
  useInvariantSize 		          = settings.flag("BoseEinstein:useInvariantSourceSize");
  useDistribution 		          = settings.flag("BoseEinstein:useDistribution");
  useRelativeDistance 	          = settings.flag("BoseEinstein:useRelativeDistance");
  useRestFrame 			          = settings.flag("BoseEinstein:useRestFrame");
  include_phase_space	          = settings.flag("BoseEinstein:includePhaseSpace");
  linear_interpolate_CDF          = settings.flag("BoseEinstein:linearInterpolateCDF");
  include_posDelQ_in_compensation = settings.flag("BoseEinstein:usePositiveShiftsForCompensation");
  compute_BE_enhancement_exactly  = settings.flag("BoseEinstein:computeBEEnhancementExactly");

  // Shape of Bose-Einstein enhancement/suppression.
  lambda 				= settings.parm("BoseEinstein:lambda");
  QRef 					= settings.parm("BoseEinstein:QRef");
  sourceDimension 		= settings.parm("BoseEinstein:sourceDimension");
  enhanceMode 			= settings.parm("BoseEinstein:enhanceMode");

  // Masses of particles with Bose-Einstein implemented.
  for (int iSpecies = 0; iSpecies < 9; ++iSpecies)
    mHadron[iSpecies] = particleData.m0( IDHADRON[iSpecies] );

  // Pair pi, K, eta and eta' masses for use in tables.
  mPair[0] = 2. * mHadron[0];
  mPair[1] = 2. * mHadron[3];
  mPair[2] = 2. * mHadron[7];
  mPair[3] = 2. * mHadron[8];

  // Loop over the four required tables. Local variables.
  for (int iTab = 0; iTab < 4; ++iTab)
    m2Pair[iTab]      = mPair[iTab] * mPair[iTab];

  number_of_pairs = 0;
  number_of_shifted_pairs = 0;
  number_of_too_close_pairs = 0;
  number_of_too_separated_pairs = 0;

  // Done.
  return true;

}



//--------------------------------------------------------------------------
// Perform Bose-Einstein corrections on an event.

bool BoseEinstein::shiftEvent( Event& event) {
  // Reset list of identical particles.
  hadronBE.resize(0);



//===========Added by Chris Plumberg================
	// if using debugging version, reset pion momentum to random value
	///*
	constexpr bool debugging = true;
	if ( debugging )
	{
		//unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
		//std::default_random_engine generator(seed);
		std::default_random_engine generator;

		const double scale = 5.0;
		std::normal_distribution<double> distribution(0.0, scale);
		// loop over particles in this event
		int lastPion = -1;
		for (int i = 0; i < event.size(); ++i)
		{
			Particle & p = event[i];
			if ( p.isHadron() and p.id() == 211 )
			{
				// record this particle index
				lastPion = i;

				//================================
				// random number generation here

				// reset positions
				p.tProd( 0.0 );
				p.xProd( 0.0*FM2MM * distribution( generator ) );
				p.yProd( 0.0*FM2MM * distribution( generator ) );
				p.zProd( FM2MM * distribution( generator ) );
				//const double tmp_rand = FM2MM * distribution( generator );
				//p.tProd( tmp_rand );
				//p.zProd( tmp_rand );

				const double pm = p.m();
				const double px = 0.0 * distribution( generator );
				const double py = 0.0 * distribution( generator );
				const double pz = 1.0 * distribution( generator );
				//const double Epi = sqrt(0.13957*0.13957 + px*px + py*py + pz*pz);
				const double Epi = sqrt(pm*pm + px*px + py*py + pz*pz);

				// reset momenta
				p.e( Epi );
				p.px( px );
				p.py( py );
				p.pz( pz );

				p.statusPos();

			}
		}

		if ( lastPion < 0 ) lastPion = event.size()-1;

		// Then add a bunch more pions...
		if (true)
		for (int i = 0; i < 100; i++)
		{
			// same "mother" for all
			int jNew = event.copy( lastPion, 99 );
			//event[ iNew ].p( hadronBE.at(i).p );

			// reset positions
			event[ jNew ].tProd( 0.0 );
			event[ jNew ].xProd( 0.0*FM2MM * distribution( generator ) );
			event[ jNew ].yProd( 0.0*FM2MM * distribution( generator ) );
			event[ jNew ].zProd( FM2MM * distribution( generator ) );
			//const double tmp_rand = FM2MM * distribution( generator );
			//event[ jNew ].tProd( tmp_rand );
			//event[ jNew ].zProd( tmp_rand );

			const double pm = event[ jNew ].m();
			const double px = 0.0 * distribution( generator );
			const double py = 0.0 * distribution( generator );
			const double pz = 1.0 * distribution( generator );
			//const double Epi = sqrt(0.13957*0.13957 + px*px + py*py + pz*pz);
			const double Epi = sqrt(pm*pm + px*px + py*py + pz*pz);

			// reset momenta
			event[ jNew ].e( Epi );
			event[ jNew ].px( px );
			event[ jNew ].py( py );
			event[ jNew ].pz( pz );

			event[ jNew ].statusPos();

			//cout << "Added particle in position = " << iNew << endl;
		}
	}

	//*/
//===========End of Chris Plumberg's addition================






	auto start = std::chrono::system_clock::now();

  // Loop over all hadron species with BE effects.
  nStored[0] = 0;
  for (int iSpecies = 0; iSpecies < 9; ++iSpecies) {
    nStored[iSpecies + 1] = nStored[iSpecies];
    if (!doPion && iSpecies <= 2) continue;
    if (!doKaon && iSpecies >= 3 && iSpecies <= 6) continue;
    if (!doEta  && iSpecies >= 7) continue;

    // Properties of current hadron species.
    int idNow = IDHADRON[ iSpecies ];
    int iTab  = ITABLE[ iSpecies ];

	if (iTab){;}

    // Loop through event record to store copies of current species.
    for (int i = 0; i < event.size(); ++i)
      if ( event[i].id() == idNow && (event[i].isFinal() or debugging) )
		{
        hadronBE.push_back(
          BoseEinsteinHadron( idNow, i, event[i].p(), event[i].m(), event[i].vProd() ) );
		}
    nStored[iSpecies + 1] = hadronBE.size();

    // Loop through pairs of identical particles and find shifts.
	switch ( enhanceMode )
	{
		case 0: // the original and the default
			/*set_QRef(iSpecies);
			for (int i1 = nStored[iSpecies]; i1 < nStored[iSpecies+1] - 1; ++i1)
			for (int i2 = i1 + 1; i2 < nStored[iSpecies+1]; ++i2)
			  shiftPair_fixedQRef( i1, i2, iTab );*/
			break;
		case 1:	// use a new cos(q*x) enhancement based on space-time interval between production points (mode 2)
			{
				bool enoughPairsToProceed = setSortedPairs( iSpecies );
				if ( enoughPairsToProceed )
				{
					cout << "BoseEinsteinCheck: NPair = " << sortedPairs.size()-2 << " in iSpecies = " << iSpecies << endl;
					shiftPairs_mode1();
				}
			}
			break;
		default:
			// Do nothing.
			break;
	}
  }

//cout << "Made it here (1)" << endl;

  // Must have at least two pairs to carry out compensation.
  if (nStored[9] < 2) return true;

  // Shift momenta and recalculate energies.
  double eSumOriginal = 0.;
  double eSumShifted  = 0.;
  double eDiffByComp  = 0.;
  for (int i = 0; i < nStored[9]; ++i) {
//cout << "(particle#=" << i << " (id=" << hadronBE.at(i).id << "): p = " << hadronBE.at(i).p;
//cout << "(particle#=" << i << " (id=" << hadronBE.at(i).id << "): pShift = " << hadronBE.at(i).pShift;
    eSumOriginal  += hadronBE.at(i).p.e();
/*cout    << setprecision(12) << setw(16)
                << "Original p and pShift: " << i
                << " (id=" << hadronBE.at(i).id << ")" << endl
                << "p=" << hadronBE.at(i).p
                << "pShift=" << hadronBE.at(i).pShift;*/
    hadronBE.at(i).p += hadronBE.at(i).pShift;
    hadronBE.at(i).p.e( sqrt( hadronBE.at(i).p.pAbs2() + hadronBE.at(i).m2 ) );
    eSumShifted   += hadronBE.at(i).p.e();
    eDiffByComp   += dot3( hadronBE.at(i).pComp, hadronBE.at(i).p)
                     / hadronBE.at(i).p.e();
/*
cout << "eDiffByComp at this step = " << eDiffByComp << endl;
cout << "pComp at this step = " << hadronBE.at(i).pComp;
cout << "p at this step = " << hadronBE.at(i).p;
cout << "e at this step = " << hadronBE.at(i).p.e() << endl;
cout 	<< setprecision(8)
		<< "Getting ready to balance energy budget (particle#=" << i << "): "
		<< eSumOriginal << "   " << eSumShifted << "   " << eDiffByComp << "   "
		<< COMPRELERR * eSumOriginal << "   " << COMPFACMAX * abs(eDiffByComp) << endl;
*/

  }

//cout << "Made it here (2)" << endl;


///*
cout 	<< setprecision(8)
		<< "Balancing energy budget: "
		<< eSumOriginal << "   " << eSumShifted << "   " << eDiffByComp << "   "
		<< COMPRELERR * eSumOriginal << "   " << COMPFACMAX * abs(eDiffByComp) << endl
		<< "TEST: " << abs(eSumShifted - eSumOriginal) << " > " << COMPRELERR * eSumOriginal << endl
		<< "TEST: " << abs(eSumShifted - eSumOriginal) << " < " << COMPFACMAX * abs(eDiffByComp) << endl;
//*/

constexpr bool perform_compensation = true;

  // Iterate compensation shift until convergence.
  int iStep = 0;
  while ( perform_compensation
    && abs(eSumShifted - eSumOriginal) > COMPRELERR * eSumOriginal
    && abs(eSumShifted - eSumOriginal) < COMPFACMAX * abs(eDiffByComp)
    && iStep < NCOMPSTEP ) {
    ++iStep;
    double compFac   = (eSumOriginal - eSumShifted) / eDiffByComp;
///*
cout 	<< setprecision(8)
		<< "Balancing energy budget(2): "
		<< compFac << "   " << eSumOriginal << "   " << eSumShifted << "   " << eDiffByComp << "   "
		<< COMPRELERR * eSumOriginal << "   " << COMPFACMAX * abs(eDiffByComp) << endl
		<< "TEST: " << abs(eSumShifted - eSumOriginal) << " > " << COMPRELERR * eSumOriginal << endl
		<< "TEST: " << abs(eSumShifted - eSumOriginal) << " < " << COMPFACMAX * abs(eDiffByComp) << endl;
//*/
    eSumShifted      = 0.;
    eDiffByComp      = 0.;
    for (int i = 0; i < nStored[9]; ++i) {
      hadronBE.at(i).p += compFac * hadronBE.at(i).pComp;
/*
      hadronBE.at(i).pShift += compFac * hadronBE.at(i).pComp;
cout 	<< setprecision(8)
		<< "Net shift at this point: " << i << "   " << hadronBE.at(i).pShift;
*/
      hadronBE.at(i).p.e( sqrt( hadronBE.at(i).p.pAbs2() + hadronBE.at(i).m2 ) );
      eSumShifted   += hadronBE.at(i).p.e();
      eDiffByComp   += dot3( hadronBE.at(i).pComp, hadronBE.at(i).p)
                       / hadronBE.at(i).p.e();
    }
  }

//cout << "Made it here (3)" << endl;

constexpr bool check_for_bad_events = false;

  // Error if no convergence, and then return without doing BE shift.
  // However, not grave enough to kill event, so return true.
  if ( perform_compensation
	and check_for_bad_events
	and abs(eSumShifted - eSumOriginal) > COMPRELERR * eSumOriginal )
  {
    infoPtr->errorMsg("Warning in BoseEinstein::shiftEvent: "
      "no consistent BE shift topology found, so skip BE");
	cout << setprecision(16) << "BoseEinsteinCheck: This event did not pass! Check: "
			<< abs(eSumShifted - eSumOriginal) << " < " << COMPRELERR * eSumOriginal << "\n";
	infoPtr->setBECShifts( false );
//if (1) exit(8);
    return true;
  }
  else
  {
	cout << setprecision(16) << "BoseEinsteinCheck: This event passes! Check: "
			<< abs(eSumShifted - eSumOriginal) << " < " << COMPRELERR * eSumOriginal << "\n";
	infoPtr->setBECShifts( true );
//if (1) exit(8);
  }


  // Store new particle copies with shifted momenta.
  for (int i = 0; i < nStored[9]; ++i) {
    int iNew = event.copy( hadronBE.at(i).iPos, 99);
    event[ iNew ].p( hadronBE.at(i).p );
  }

    auto end = std::chrono::system_clock::now();

    std::chrono::duration<double> elapsed_seconds = end-start;
std::cout << "BoseEinsteinCheck: elapsed time: " << elapsed_seconds.count() << " s" << "\n";

  // Done.
  return true;

}



//--------------------------------
// Construct list of sorted pairs.
bool BoseEinstein::setSortedPairs( int iSpecies )
{
	// Reset.
    int iTab  = ITABLE[ iSpecies ];
	if (iTab){;}

	sortedPairs.clear();

	pairs_sorted_by_qxPRF.clear();
	pairs_sorted_by_qyPRF.clear();
	pairs_sorted_by_qzPRF.clear();
	pairs_sorted_by_abs_qxPRF.clear();
	pairs_sorted_by_abs_qyPRF.clear();
	pairs_sorted_by_abs_qzPRF.clear();

	pairs_sorted_by_qx.clear();
	pairs_sorted_by_qy.clear();
	pairs_sorted_by_qz.clear();
	pairs_sorted_by_abs_qx.clear();
	pairs_sorted_by_abs_qy.clear();
	pairs_sorted_by_abs_qz.clear();

	// get all values in vector first
	for (int i1 = nStored[iSpecies]; i1 < nStored[iSpecies+1] - 1; ++i1)
	for (int i2 = i1 + 1; i2 < nStored[iSpecies+1]; ++i2)
	{
		Vec4 q = hadronBE.at(i1).p - hadronBE.at(i2).p;
		Vec4 qPRF = q;
		qPRF.bstback( 0.5*( hadronBE.at(i1).p + hadronBE.at(i2).p ) );

		/*sortedPairs.push_back(
			std::make_pair(
				sqrt( m2(hadronBE.at(i1).p, hadronBE.at(i2).p) - m2Pair[iTab] ),
				std::make_pair(i1, i2)
			)
		);*/
		sortedPairs.push_back( std::make_pair( qPRF.pAbs(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_qxPRF.push_back( std::make_pair( qPRF.px(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_qyPRF.push_back( std::make_pair( qPRF.py(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_qzPRF.push_back( std::make_pair( qPRF.pz(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qxPRF.push_back( std::make_pair( abs(qPRF.px()), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qyPRF.push_back( std::make_pair( abs(qPRF.py()), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qzPRF.push_back( std::make_pair( abs(qPRF.pz()), std::make_pair(i1, i2) ) );

		pairs_sorted_by_qx.push_back( std::make_pair( q.px(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_qy.push_back( std::make_pair( q.py(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_qz.push_back( std::make_pair( q.pz(), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qx.push_back( std::make_pair( abs(q.px()), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qy.push_back( std::make_pair( abs(q.py()), std::make_pair(i1, i2) ) );
		pairs_sorted_by_abs_qz.push_back( std::make_pair( abs(q.pz()), std::make_pair(i1, i2) ) );
	}

	// check if there are enough pairs of this species to do shift
	if (sortedPairs.size() < 2)
	{
		//cout << "Not enough sorted pairs of species with pid=" << idNow << endl;
		return false;
	}

	// THEN sort them (sorts on first column in ascending order automatically)
	sort( sortedPairs.begin(), sortedPairs.end() );
	sort( pairs_sorted_by_qxPRF.begin(), pairs_sorted_by_qxPRF.end() );
	sort( pairs_sorted_by_qyPRF.begin(), pairs_sorted_by_qyPRF.end() );
	sort( pairs_sorted_by_qzPRF.begin(), pairs_sorted_by_qzPRF.end() );
	sort( pairs_sorted_by_abs_qxPRF.begin(), pairs_sorted_by_abs_qxPRF.end() );
	sort( pairs_sorted_by_abs_qyPRF.begin(), pairs_sorted_by_abs_qyPRF.end() );
	sort( pairs_sorted_by_abs_qzPRF.begin(), pairs_sorted_by_abs_qzPRF.end() );

	sort( pairs_sorted_by_qx.begin(), pairs_sorted_by_qx.end() );
	sort( pairs_sorted_by_qy.begin(), pairs_sorted_by_qy.end() );
	sort( pairs_sorted_by_qz.begin(), pairs_sorted_by_qz.end() );
	sort( pairs_sorted_by_abs_qx.begin(), pairs_sorted_by_abs_qx.end() );
	sort( pairs_sorted_by_abs_qy.begin(), pairs_sorted_by_abs_qy.end() );
	sort( pairs_sorted_by_abs_qz.begin(), pairs_sorted_by_abs_qz.end() );

	// add fake first "pair"
	sortedPairs.insert(sortedPairs.begin(), std::make_pair( 0.0, std::make_pair(-1, -1) ) );

	// add fake last "pair" (new QVal is 10% larger than last one, just for definiteness)
	sortedPairs.push_back( std::make_pair( 1.1*sortedPairs.back().first, std::make_pair(-1, -1) ) );

	return (true);
}


//------------------------------------------------
// Calculate shift and (unnormalized) compensation
// for pair using space-time interval and and
// mode 1 of evaluating BE enhancement.
void BoseEinstein::shiftPairs_mode1()
{
	//----------------------------------
	// Set LHS and RHS of shift relation
	// at each pair Q.
	vector< pair< double, double > > LHS, RHS;
	evaluate_shift_relation_at_pair( pairs_sorted_by_abs_qz, LHS, RHS );

	/*
	// some output to check stuff
	const int npairs = LHS.size();

	cout << "CHECK LHS AND RHS AND SHIFTS: " << endl;
	for (int i = 0; i < npairs; i++)
	{
		const auto & thisPair = sorted_list_of_pairs.at(i);
		const double this_qz = thisPair.first;
		const int this1 = thisPair.second.first;
		const int this2 = thisPair.second.second;
		Vec4 xDiff = ( hadronBE.at(this1).x - hadronBE.at(this2).x ) * MM2FM / HBARC;
		const double Delta_z = xDiff.pz();	// units are 1/GeV here

		const double thisPair_shift = Newtons_Method( this_qz, Delta_z );

		cout << setprecision(24) << "CHECK: " << LHS.at(i).first << "   " << LHS.at(i).second << "   " << RHS.at(i).second << "   " << thisPair_shift << endl;
	}

	if (1) exit(8);
	*/

	compute_shifts( pairs_sorted_by_abs_qz );


	return;
}



//---------------------------------------
// Compute and store shits for each pair.
void BoseEinstein::compute_shifts(
			const vector< pair< double, pair <int,int> > > & sorted_list_of_pairs
			)
{
	const int npairs = sorted_list_of_pairs.size();

	vector<double> pairShifts;
	vector<bool> this_pair_shifted;

	pairShifts.reserve( npairs );
	this_pair_shifted.reserve( npairs );

	// Compute the pair shifts themselves.
	for (int i = 0; i < npairs; i++)
	{
		const auto & thisPair = sorted_list_of_pairs.at(i);
		const double this_qz = thisPair.first;
		const int this1 = thisPair.second.first;
		const int this2 = thisPair.second.second;
		Vec4 xDiff = ( hadronBE.at(this1).x - hadronBE.at(this2).x ) * MM2FM / HBARC;
		const double Delta_z = xDiff.pz();	// units are 1/GeV here

		const double thisPair_shift = Newtons_Method( this_qz, Delta_z );
		pairShifts.push_back( thisPair_shift );
		if (this1==0 or this2==0)	// choose a particle to track
			cout << setprecision(24) << "CHECK: " << this1 << "   " << this2 << "   " << this_qz << "   " << Delta_z*HBARC << "   " << thisPair_shift << endl;
		this_pair_shifted.push_back( true );
	}

	// Store them for each pair.
	int pairIndex = 0;
	int number_of_pairs_shifted = 0, number_of_pairs_not_shifted = 0;
	for (const auto & iPair : sorted_list_of_pairs)
	{
		const double this_qz = iPair.first;
		const int i1 = iPair.second.first;
		const int i2 = iPair.second.second;

		constexpr bool rescale_pair_momenta = true;

		const double net_qz_shift = 0.5*pairShifts.at(pairIndex);
		const double factor = net_qz_shift / this_qz;

		// Add shifts to sum. (Energy component dummy.)
		//Vec4 pDiff(0.0, 0.0, 0.0, net_qz_shift);
		Vec4 pDiff = factor * (hadronBE.at(i1).p - hadronBE.at(i2).p);
		if (i1==0 or i2==0)	// choose a particle to track
			cout << setprecision(24) << "CHECK: " << i1 << "   " << i2 << "   " << this_qz << "   " << net_qz_shift << "   " << factor << "   " << pDiff;

		if ( rescale_pair_momenta or this_pair_shifted.at(pairIndex) )
		{
			// Compute appropriate shift for pair
			number_of_pairs_shifted++;

			hadronBE.at(i1).pShift += pDiff;
			hadronBE.at(i2).pShift -= pDiff;

			if ( rescale_pair_momenta )
			{
				// add symmetrically to both momenta
				pDiff = 0.5*(hadronBE.at(i1).p + hadronBE.at(i2).p);
				hadronBE.at(i1).pComp += pDiff;
				hadronBE.at(i2).pComp += pDiff;
			}
		}
		else
		{
			// Use computed shift for compensation
			number_of_pairs_not_shifted++;

			//*/
			//Vec4 pDiff = hadronBE.at(i1).p - hadronBE.at(i2).p;
			hadronBE.at(i1).pComp += pDiff;
			hadronBE.at(i2).pComp -= pDiff;
		}

		pairIndex++;

	}

	if ( BE_VERBOSE or true )
	{
		cout << "number_of_pairs_shifted = " << number_of_pairs_shifted << endl;
		cout << "number_of_pairs_not_shifted = " << number_of_pairs_not_shifted << endl;
	}

	return;
}




//-------------------------------------
// Compute the unshifted pair integrals
// at each pair's relative momentum.
void BoseEinstein::evaluate_shift_relation_at_pair(
			const vector< pair< double, pair <int,int> > > & sorted_list_of_pairs,
			vector< pair< double, double > > & LHS,
			vector< pair< double, double > > & RHS
			)
{

	//-------
	// Reset.
	LHS.clear();
	RHS.clear();

	//------------------
	// Set LHS integral.
	set_LHS( sorted_list_of_pairs, LHS );

	//------------------
	// Set RHS integral.
	set_RHS( sorted_list_of_pairs, RHS );

	return;
}

double BoseEinstein::Newtons_Method( const double a, const double b )
{
	const double ACCURACY = 1.e-6;
	const int MAXTRIES = 100;

	/*const double guess1 = -1.0/b;
	const double guess2 = 0.0;
	const double guess3 = 1.0/b;

	const double f1 = guess1*b + sin(b*(a+guess1));
	const double f2 = guess2*b + sin(b*(a+guess2));
	const double f3 = guess3*b + sin(b*(a+guess3));

	bool f1_lt_f2 = (f1*f1 < f2*f2);
	bool f1_lt_f3 = (f1*f1 < f3*f3);
	bool f2_lt_f3 = (f2*f2 < f3*f3);

	// Solve equation given by x*b + sin((a+x)*b) == 0
	const double initial_guess = guess1 * static_cast<double>(  f1_lt_f2 and f1_lt_f3 )
									+ guess2 * static_cast<double>( not f1_lt_f2 and f2_lt_f3 )
									+ guess3 * static_cast<double>( not f1_lt_f3 and not f2_lt_f3 );*/

	const double guess1 = -1.0/b;
	const double guess2 = 1.0/b;

	const double f1 = guess1*b + sin(b*(a+guess1));
	const double f2 = guess2*b + sin(b*(a+guess2));

	//cout << f1 << "   " << f2 << endl;

	// Solve equation given by x*b + sin((a+x)*b) == 0
	const double initial_guess = ( f1*f1 < f2*f2 ) ? guess1 : guess2;

	double x = initial_guess;
	double f = x*b + sin(b*(a+x));

	int ntries = 0;
	while ( abs(f) > ACCURACY and ntries < MAXTRIES )
	{
		double fp = b*(1.0 + cos(b*(a+x)));
		//cout << setprecision(24) << "ntries = " << ntries << ": " << x << "   " << f << "   " << fp << endl;
		if ( abs(fp) < 1.e-100 ) break;
		f = x*b + sin(b*(a+x));
		x -= f / fp;
		ntries++;
	}

	if ( ntries == MAXTRIES ) cout << "WARNING: maximum number of tries reached! a=" << a << ", b=" << b << "; root x = " << x << endl;

	//if ( abs(x) > 0.1*a ) cout << setprecision(24) << "WARNING: large shift! a=" << a << ", b=" << b << "; root x = " << x << endl;

	return (x);
}


//-------------------------------------
// Set lefthand side of shift relation.
void BoseEinstein::set_LHS(
			const vector< pair< double, pair <int,int> > > & sorted_list_of_pairs,
			vector< pair< double, double > > & LHS )
{

	// LHS is symmetric integral about q = 0 up to q = q_pair, for each pair
	// ==>> most efficient to start with smallest |q_pair| and work my way up
	const int npairs = sorted_list_of_pairs.size();
	LHS.reserve( npairs );

	for (const auto & eachPair : sorted_list_of_pairs)
	{
		// assumes pair density is constant for now
		const double LHS_integral = 2.0 * eachPair.first;

		LHS.push_back( std::make_pair( eachPair.first, LHS_integral ) );
	}

	return;
}


//-------------------------------------
// Set righthand side of shift relation.
void BoseEinstein::set_RHS(
			const vector< pair< double, pair <int,int> > > & sorted_list_of_pairs,
			vector< pair< double, double > > & RHS )
{

	// RHS similar to LHS
	const int npairs = sorted_list_of_pairs.size();
	//const double one_by_npairs = 1.0 / npairs;
	RHS.reserve( npairs );

	for (const auto & eachPair : sorted_list_of_pairs)
	{
		// assumes pair density is constant for now
		const double this_qz = eachPair.first;
		const int this1 = eachPair.second.first;
		const int this2 = eachPair.second.second;

		double RHS_integral = 2.0 * this_qz;

		int npairs_in_average = 0;
		double RHS_BE_enhancement = 0.0;
		for (const auto & iPair : sorted_list_of_pairs)
		{
			const int i1 = iPair.second.first;
			const int i2 = iPair.second.second;

			if ( this1 != i1 and this2 != i2 ) continue;

			Vec4 xDiffPRF = ( hadronBE.at(i1).x - hadronBE.at(i2).x ) * MM2FM / HBARC;
			//xDiffPRF.bstback( 0.5*(hadronBE.at(i1).p + hadronBE.at(i2).p) );
			const double Delta_z = xDiffPRF.pz();

			RHS_BE_enhancement += 2.0 * sin(this_qz*Delta_z) / Delta_z;
			++npairs_in_average;
		}

		RHS_integral += RHS_BE_enhancement / static_cast<double>(npairs_in_average);
		RHS.push_back( std::make_pair( eachPair.first, RHS_integral ) );
	}

	return;
}


//----------------------
// Set effective source.
void BoseEinstein::set_effective_source()
{

	// set grids
	const int Qgridsize = static_cast<int>(Qmaximum / dQ) + 1;
	Qgrid.assign( Qgridsize, 0.0 );
	phase_space.assign( Qgridsize, 0.0 );
	effective_source.assign( Qgridsize, 0.0 );
	integrated_effective_source.assign( Qgridsize, 0.0 );

	for (int iPair = 1; iPair < (int)sortedPairs.size()-1; iPair++)
	{
		auto eachPair = sortedPairs.at(iPair);

		const int i1 = eachPair.second.first;
		const int i2 = eachPair.second.second;
		Vec4 xDiffPRF = ( hadronBE.at(i1).x - hadronBE.at(i2).x ) * MM2FM / HBARC;
		xDiffPRF.bstback( 0.5*(hadronBE.at(i1).p + hadronBE.at(i2).p) );

		const double xDiffval = xDiffPRF.pAbs();

		double currentQ = 0.0;
		for (int iQ = 0; iQ < (int)effective_source.size(); iQ++)
		{
			effective_source[iQ] += cos(currentQ * xDiffval);
			currentQ += dQ;
		}
	}

	double currentQ = 0.0;
	for (int iQ = 0; iQ < (int)Qgrid.size(); iQ++)
		phase_space[iQ] = 1.0;

	//reset
	double previousIntegrand = 0.0, currentIntegrand = 0.0;
	currentQ = 0.0;
	double runningIntegral = 0.0;
	for (int iQ = 0; iQ < (int)Qgrid.size(); iQ++)
	{
		Qgrid[iQ] = currentQ;
		effective_source[iQ] /= (double)(sortedPairs.size()-2);
		previousIntegrand = currentIntegrand;
		currentIntegrand = phase_space[iQ] * effective_source[iQ];
		runningIntegral += 0.5*dQ*(currentIntegrand + previousIntegrand);
		integrated_effective_source[iQ] = runningIntegral;
		cout << "Effective_source: " << setprecision(12)
				<< currentQ << "   "
				<< phase_space[iQ] << "   "
				<< effective_source[iQ] << "   "
				<< integrated_effective_source[iQ] << endl;
		currentQ += dQ;
	}
	//if (1) return;
	if (1) exit (8);
}


//==========================================================================

} // end namespace Pythia8
